{"version":3,"file":"utils-BX1yQjyX.js","sources":["../../../src/utils/inputSanitizer.ts","../../../src/utils/debounce.ts","../../../src/utils/performance.ts"],"sourcesContent":["/**\n * Input sanitization utilities for the frontend\n */\n\nexport interface SanitizationResult {\n  sanitized: string;\n  wasModified: boolean;\n  warnings: string[];\n}\n\nexport class InputSanitizer {\n  private static readonly DANGEROUS_PATTERNS = [\n    // Script injection patterns\n    /<script[^>]*>.*?<\\/script>/gi,\n    /javascript:/gi,\n    /vbscript:/gi,\n\n    // Event handlers\n    /on\\w+\\s*=/gi,\n\n    // Data URLs with scripts\n    /data:text\\/html/gi,\n    /data:application\\/javascript/gi,\n\n    // Common XSS patterns\n    /eval\\s*\\(/gi,\n    /document\\.cookie/gi,\n    /window\\.location/gi,\n    /alert\\s*\\(/gi,\n\n    // SQL injection patterns (basic)\n    /union\\s+select/gi,\n    /drop\\s+table/gi,\n    /delete\\s+from/gi,\n  ];\n\n  private static readonly HTML_ENTITIES: Record<string, string> = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#x27;\",\n    \"/\": \"&#x2F;\",\n  };\n\n  /**\n   * Sanitize user input by removing dangerous patterns and encoding HTML entities\n   */\n  static sanitizeInput(input: string): SanitizationResult {\n    if (!input || typeof input !== \"string\") {\n      return {\n        sanitized: \"\",\n        wasModified: false,\n        warnings: [],\n      };\n    }\n\n    let sanitized = input;\n    const warnings: string[] = [];\n    let wasModified = false;\n\n    // Check for dangerous patterns\n    for (const pattern of this.DANGEROUS_PATTERNS) {\n      if (pattern.test(sanitized)) {\n        sanitized = sanitized.replace(pattern, \"\");\n        wasModified = true;\n        warnings.push(\"Potentially unsafe content was removed from your input\");\n        break; // Only show one warning to avoid spam\n      }\n    }\n\n    // Encode HTML entities in the remaining content\n    const originalLength = sanitized.length;\n    sanitized = this.encodeHTMLEntities(sanitized);\n\n    if (sanitized.length !== originalLength) {\n      wasModified = true;\n    }\n\n    // Trim excessive whitespace\n    const trimmed = sanitized.trim().replace(/\\s+/g, \" \");\n    if (trimmed !== sanitized) {\n      sanitized = trimmed;\n      wasModified = true;\n    }\n\n    return {\n      sanitized,\n      wasModified,\n      warnings,\n    };\n  }\n\n  /**\n   * Sanitize prompt input specifically for SVG generation\n   */\n  static sanitizePrompt(prompt: string): SanitizationResult {\n    const result = this.sanitizeInput(prompt);\n\n    // Additional prompt-specific validation\n    if (result.sanitized.length > 500) {\n      result.sanitized = result.sanitized.substring(0, 500);\n      result.wasModified = true;\n      result.warnings.push(\"Prompt was truncated to 500 characters\");\n    }\n\n    // Check for excessive special characters\n    const specialCharCount = (\n      result.sanitized.match(/[^a-zA-Z0-9\\s.,!?-]/g) || []\n    ).length;\n    const totalLength = result.sanitized.length;\n\n    if (totalLength > 0 && specialCharCount / totalLength > 0.3) {\n      result.warnings.push(\n        \"Your prompt contains many special characters which may affect generation quality\"\n      );\n    }\n\n    return result;\n  }\n\n  /**\n   * Validate and sanitize numeric input\n   */\n  static sanitizeNumber(\n    value: any,\n    min: number,\n    max: number,\n    defaultValue: number\n  ): { value: number; wasModified: boolean; warnings: string[] } {\n    const warnings: string[] = [];\n    let wasModified = false;\n    let numValue: number;\n\n    // Convert to number\n    if (typeof value === \"string\") {\n      numValue = parseFloat(value);\n    } else if (typeof value === \"number\") {\n      numValue = value;\n    } else {\n      numValue = defaultValue;\n      wasModified = true;\n      warnings.push(\"Invalid number format, using default value\");\n    }\n\n    // Check if it's a valid number\n    if (isNaN(numValue) || !isFinite(numValue)) {\n      numValue = defaultValue;\n      wasModified = true;\n      warnings.push(\"Invalid number, using default value\");\n    }\n\n    // Clamp to range\n    if (numValue < min) {\n      numValue = min;\n      wasModified = true;\n      warnings.push(`Value was below minimum (${min}), adjusted to minimum`);\n    } else if (numValue > max) {\n      numValue = max;\n      wasModified = true;\n      warnings.push(`Value was above maximum (${max}), adjusted to maximum`);\n    }\n\n    // Round to reasonable precision\n    const rounded = Math.round(numValue * 100) / 100;\n    if (rounded !== numValue) {\n      numValue = rounded;\n      wasModified = true;\n    }\n\n    return {\n      value: numValue,\n      wasModified,\n      warnings,\n    };\n  }\n\n  /**\n   * Sanitize color values\n   */\n  static sanitizeColor(color: string): SanitizationResult {\n    if (!color || typeof color !== \"string\") {\n      return {\n        sanitized: \"#000000\",\n        wasModified: true,\n        warnings: [\"Invalid color format, using black\"],\n      };\n    }\n\n    let sanitized = color.trim().toLowerCase();\n    const warnings: string[] = [];\n    let wasModified = false;\n\n    // Remove any dangerous content\n    const inputResult = this.sanitizeInput(sanitized);\n    sanitized = inputResult.sanitized;\n    wasModified = inputResult.wasModified;\n    warnings.push(...inputResult.warnings);\n\n    // Validate hex color format\n    if (sanitized.startsWith(\"#\")) {\n      const hexPattern = /^#([0-9a-f]{3}|[0-9a-f]{6})$/i;\n      if (!hexPattern.test(sanitized)) {\n        sanitized = \"#000000\";\n        wasModified = true;\n        warnings.push(\"Invalid hex color format, using black\");\n      }\n    } else {\n      // For named colors, we'll be restrictive and only allow basic ones\n      const allowedColors = [\n        \"red\",\n        \"green\",\n        \"blue\",\n        \"yellow\",\n        \"orange\",\n        \"purple\",\n        \"pink\",\n        \"black\",\n        \"white\",\n        \"gray\",\n        \"grey\",\n        \"brown\",\n        \"cyan\",\n        \"magenta\",\n        \"lime\",\n        \"navy\",\n        \"maroon\",\n        \"olive\",\n        \"teal\",\n        \"silver\",\n        \"gold\",\n      ];\n\n      if (!allowedColors.includes(sanitized)) {\n        sanitized = \"#000000\";\n        wasModified = true;\n        warnings.push(\"Unsupported color name, using black\");\n      }\n    }\n\n    return {\n      sanitized,\n      wasModified,\n      warnings,\n    };\n  }\n\n  /**\n   * Encode HTML entities to prevent XSS\n   */\n  private static encodeHTMLEntities(str: string): string {\n    return str.replace(/[&<>\"'\\/]/g, (match) => {\n      return this.HTML_ENTITIES[match] || match;\n    });\n  }\n\n  /**\n   * Validate that a string contains only safe characters\n   */\n  static containsOnlySafeCharacters(input: string): boolean {\n    // Allow alphanumeric, spaces, and common punctuation\n    const safePattern = /^[a-zA-Z0-9\\s.,!?;:()\\-_+=\\[\\]{}'\"@#$%^&*\\/\\\\|`~]*$/;\n    return safePattern.test(input);\n  }\n\n  /**\n   * Check if input appears to be malicious\n   */\n  static isSuspiciousInput(input: string): boolean {\n    if (!input || typeof input !== \"string\") {\n      return false;\n    }\n\n    // Check for dangerous patterns\n    return this.DANGEROUS_PATTERNS.some((pattern) => pattern.test(input));\n  }\n}\n","/**\n * Debounce utility for performance optimization\n */\n\nexport function debounce<T extends (...args: any[]) => any>(\n  func: T,\n  wait: number,\n  immediate = false\n): (...args: Parameters<T>) => void {\n  let timeout: ReturnType<typeof setTimeout> | null = null;\n\n  return function executedFunction(...args: Parameters<T>) {\n    const later = () => {\n      timeout = null;\n      if (!immediate) func(...args);\n    };\n\n    const callNow = immediate && !timeout;\n\n    if (timeout !== null) {\n      clearTimeout(timeout);\n    }\n\n    timeout = setTimeout(later, wait);\n\n    if (callNow) func(...args);\n  };\n}\n\nexport function throttle<T extends (...args: any[]) => any>(\n  func: T,\n  limit: number\n): (...args: Parameters<T>) => void {\n  let inThrottle: boolean;\n\n  return function executedFunction(this: any, ...args: Parameters<T>) {\n    if (!inThrottle) {\n      func.apply(this, args);\n      inThrottle = true;\n      setTimeout(() => (inThrottle = false), limit);\n    }\n  };\n}\n\n/**\n * Advanced debounce with leading and trailing edge options\n */\nexport function advancedDebounce<T extends (...args: any[]) => any>(\n  func: T,\n  wait: number,\n  options: {\n    leading?: boolean;\n    trailing?: boolean;\n    maxWait?: number;\n  } = {}\n): (...args: Parameters<T>) => void {\n  let lastCallTime: number | undefined;\n  let lastInvokeTime = 0;\n  let timerId: ReturnType<typeof setTimeout> | undefined;\n  let lastArgs: Parameters<T> | undefined;\n\n  const { leading = false, trailing = true, maxWait } = options;\n\n  function invokeFunc(time: number) {\n    const args = lastArgs!;\n    lastArgs = undefined;\n    lastInvokeTime = time;\n    return func(...args);\n  }\n\n  function leadingEdge(time: number) {\n    lastInvokeTime = time;\n    timerId = setTimeout(timerExpired, wait);\n    return leading ? invokeFunc(time) : undefined;\n  }\n\n  function remainingWait(time: number) {\n    const timeSinceLastCall = time - lastCallTime!;\n    const timeSinceLastInvoke = time - lastInvokeTime;\n    const timeWaiting = wait - timeSinceLastCall;\n\n    return maxWait !== undefined\n      ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time: number) {\n    const timeSinceLastCall = time - lastCallTime!;\n    const timeSinceLastInvoke = time - lastInvokeTime;\n\n    return (\n      lastCallTime === undefined ||\n      timeSinceLastCall >= wait ||\n      timeSinceLastCall < 0 ||\n      (maxWait !== undefined && timeSinceLastInvoke >= maxWait)\n    );\n  }\n\n  function timerExpired() {\n    const time = Date.now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time: number) {\n    timerId = undefined;\n\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = undefined;\n    return undefined;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = undefined;\n    lastCallTime = undefined;\n    timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? undefined : trailingEdge(Date.now());\n  }\n\n  function pending() {\n    return timerId !== undefined;\n  }\n\n  function debounced(...args: Parameters<T>) {\n    const time = Date.now();\n    const isInvoking = shouldInvoke(time);\n\n    lastArgs = args;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxWait) {\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n  }\n\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  debounced.pending = pending;\n\n  return debounced;\n}\n","/**\n * Performance monitoring utilities\n */\n\nexport interface PerformanceMetric {\n  name: string;\n  startTime: number;\n  endTime?: number;\n  duration?: number;\n  metadata?: Record<string, any>;\n}\n\nexport interface PerformanceReport {\n  metrics: PerformanceMetric[];\n  summary: {\n    totalOperations: number;\n    averageDuration: number;\n    slowestOperation: PerformanceMetric | null;\n    fastestOperation: PerformanceMetric | null;\n  };\n}\n\nclass PerformanceMonitor {\n  private metrics: PerformanceMetric[] = [];\n  private activeTimers = new Map<string, number>();\n\n  /**\n   * Start timing an operation\n   */\n  start(name: string, metadata?: Record<string, any>): void {\n    const startTime = performance.now();\n    this.activeTimers.set(name, startTime);\n\n    this.metrics.push({\n      name,\n      startTime,\n      metadata,\n    });\n  }\n\n  /**\n   * End timing an operation\n   */\n  end(name: string): number | null {\n    const endTime = performance.now();\n    const startTime = this.activeTimers.get(name);\n\n    if (!startTime) {\n      console.warn(`Performance timer '${name}' was not started`);\n      return null;\n    }\n\n    const duration = endTime - startTime;\n    this.activeTimers.delete(name);\n\n    // Update the metric\n    const metric = this.metrics.find((m) => m.name === name && !m.endTime);\n    if (metric) {\n      metric.endTime = endTime;\n      metric.duration = duration;\n    }\n\n    return duration;\n  }\n\n  /**\n   * Time a function execution\n   */\n  async time<T>(\n    name: string,\n    fn: () => Promise<T>,\n    metadata?: Record<string, any>\n  ): Promise<T> {\n    this.start(name, metadata);\n    try {\n      const result = await fn();\n      this.end(name);\n      return result;\n    } catch (error) {\n      this.end(name);\n      throw error;\n    }\n  }\n\n  /**\n   * Time a synchronous function execution\n   */\n  timeSync<T>(name: string, fn: () => T, metadata?: Record<string, any>): T {\n    this.start(name, metadata);\n    try {\n      const result = fn();\n      this.end(name);\n      return result;\n    } catch (error) {\n      this.end(name);\n      throw error;\n    }\n  }\n\n  /**\n   * Get performance report\n   */\n  getReport(): PerformanceReport {\n    const completedMetrics = this.metrics.filter(\n      (m) => m.duration !== undefined\n    );\n\n    if (completedMetrics.length === 0) {\n      return {\n        metrics: [],\n        summary: {\n          totalOperations: 0,\n          averageDuration: 0,\n          slowestOperation: null,\n          fastestOperation: null,\n        },\n      };\n    }\n\n    const durations = completedMetrics.map((m) => m.duration!);\n    const averageDuration =\n      durations.reduce((sum, d) => sum + d, 0) / durations.length;\n\n    const slowestOperation = completedMetrics.reduce((slowest, current) =>\n      current.duration! > slowest.duration! ? current : slowest\n    );\n\n    const fastestOperation = completedMetrics.reduce((fastest, current) =>\n      current.duration! < fastest.duration! ? current : fastest\n    );\n\n    return {\n      metrics: [...completedMetrics],\n      summary: {\n        totalOperations: completedMetrics.length,\n        averageDuration: Math.round(averageDuration * 100) / 100,\n        slowestOperation,\n        fastestOperation,\n      },\n    };\n  }\n\n  /**\n   * Clear all metrics\n   */\n  clear(): void {\n    this.metrics = [];\n    this.activeTimers.clear();\n  }\n\n  /**\n   * Get metrics for a specific operation\n   */\n  getMetricsFor(name: string): PerformanceMetric[] {\n    return this.metrics.filter((m) => m.name === name);\n  }\n\n  /**\n   * Log performance report to console\n   */\n  logReport(): void {\n    const report = this.getReport();\n\n    console.group(\"ðŸš€ Performance Report\");\n    console.log(`Total Operations: ${report.summary.totalOperations}`);\n    console.log(`Average Duration: ${report.summary.averageDuration}ms`);\n\n    if (report.summary.slowestOperation) {\n      console.log(\n        `Slowest: ${report.summary.slowestOperation.name} (${report.summary.slowestOperation.duration}ms)`\n      );\n    }\n\n    if (report.summary.fastestOperation) {\n      console.log(\n        `Fastest: ${report.summary.fastestOperation.name} (${report.summary.fastestOperation.duration}ms)`\n      );\n    }\n\n    console.table(\n      report.metrics.map((m) => ({\n        Operation: m.name,\n        Duration: `${m.duration}ms`,\n        Metadata: JSON.stringify(m.metadata || {}),\n      }))\n    );\n\n    console.groupEnd();\n  }\n}\n\n// Global performance monitor instance\nexport const performanceMonitor = new PerformanceMonitor();\n\n/**\n * Decorator for timing method execution\n */\nexport function timed(name?: string) {\n  return function (\n    target: any,\n    propertyKey: string,\n    descriptor: PropertyDescriptor\n  ) {\n    const originalMethod = descriptor.value;\n    const timerName = name || `${target.constructor.name}.${propertyKey}`;\n\n    descriptor.value = async function (...args: any[]) {\n      return performanceMonitor.time(timerName, () =>\n        originalMethod.apply(this, args)\n      );\n    };\n\n    return descriptor;\n  };\n}\n\n/**\n * Memory usage monitoring\n */\n\ninterface MemoryInfo {\n  usedJSHeapSize: number;\n  totalJSHeapSize: number;\n  jsHeapSizeLimit: number;\n}\n\nexport class MemoryMonitor {\n  private snapshots: Array<{\n    timestamp: number;\n    usage: MemoryInfo;\n    label?: string;\n  }> = [];\n\n  /**\n   * Take a memory snapshot\n   */\n  snapshot(label?: string): MemoryInfo | null {\n    const performanceMemory = (performance as any).memory;\n    if (!performanceMemory) {\n      console.warn(\"Memory monitoring not available in this environment\");\n      return null;\n    }\n\n    const usage: MemoryInfo = {\n      usedJSHeapSize: performanceMemory.usedJSHeapSize,\n      totalJSHeapSize: performanceMemory.totalJSHeapSize,\n      jsHeapSizeLimit: performanceMemory.jsHeapSizeLimit,\n    };\n\n    this.snapshots.push({\n      timestamp: Date.now(),\n      usage,\n      label,\n    });\n\n    return usage;\n  }\n\n  /**\n   * Get memory usage difference between two snapshots\n   */\n  getDifference(startLabel: string, endLabel: string): number | null {\n    const start = this.snapshots.find((s) => s.label === startLabel);\n    const end = this.snapshots.find((s) => s.label === endLabel);\n\n    if (!start || !end) {\n      return null;\n    }\n\n    return end.usage.usedJSHeapSize - start.usage.usedJSHeapSize;\n  }\n\n  /**\n   * Get all snapshots\n   */\n  getSnapshots() {\n    return [...this.snapshots];\n  }\n\n  /**\n   * Clear all snapshots\n   */\n  clear(): void {\n    this.snapshots = [];\n  }\n\n  /**\n   * Format bytes to human readable format\n   */\n  formatBytes(bytes: number): string {\n    const sizes = [\"Bytes\", \"KB\", \"MB\", \"GB\"];\n    if (bytes === 0) return \"0 Bytes\";\n    const i = Math.floor(Math.log(bytes) / Math.log(1024));\n    return Math.round((bytes / Math.pow(1024, i)) * 100) / 100 + \" \" + sizes[i];\n  }\n\n  /**\n   * Log memory report\n   */\n  logReport(): void {\n    if (this.snapshots.length === 0) {\n      console.log(\"No memory snapshots available\");\n      return;\n    }\n\n    console.group(\"ðŸ’¾ Memory Report\");\n\n    this.snapshots.forEach((snapshot, index) => {\n      console.log(\n        `${index + 1}. ${snapshot.label || \"Unnamed\"}: ${this.formatBytes(snapshot.usage.usedJSHeapSize)}`\n      );\n    });\n\n    if (this.snapshots.length >= 2) {\n      const first = this.snapshots[0];\n      const last = this.snapshots[this.snapshots.length - 1];\n      const difference = last.usage.usedJSHeapSize - first.usage.usedJSHeapSize;\n\n      console.log(\n        `Total Change: ${this.formatBytes(Math.abs(difference))} ${difference >= 0 ? \"increase\" : \"decrease\"}`\n      );\n    }\n\n    console.groupEnd();\n  }\n}\n\n// Global memory monitor instance\nexport const memoryMonitor = new MemoryMonitor();\n\n/**\n * FPS monitoring for smooth animations\n */\nexport class FPSMonitor {\n  private frames: number[] = [];\n  private lastTime = 0;\n  private isRunning = false;\n\n  /**\n   * Start FPS monitoring\n   */\n  start(): void {\n    if (this.isRunning) return;\n\n    this.isRunning = true;\n    this.lastTime = performance.now();\n    this.frames = [];\n    this.tick();\n  }\n\n  /**\n   * Stop FPS monitoring\n   */\n  stop(): void {\n    this.isRunning = false;\n  }\n\n  private tick = (): void => {\n    if (!this.isRunning) return;\n\n    const now = performance.now();\n    const delta = now - this.lastTime;\n    this.lastTime = now;\n\n    const fps = 1000 / delta;\n    this.frames.push(fps);\n\n    // Keep only last 60 frames (1 second at 60fps)\n    if (this.frames.length > 60) {\n      this.frames.shift();\n    }\n\n    requestAnimationFrame(this.tick);\n  };\n\n  /**\n   * Get current FPS\n   */\n  getCurrentFPS(): number {\n    if (this.frames.length === 0) return 0;\n    return this.frames[this.frames.length - 1];\n  }\n\n  /**\n   * Get average FPS\n   */\n  getAverageFPS(): number {\n    if (this.frames.length === 0) return 0;\n    const sum = this.frames.reduce((a, b) => a + b, 0);\n    return sum / this.frames.length;\n  }\n\n  /**\n   * Get FPS statistics\n   */\n  getStats() {\n    if (this.frames.length === 0) {\n      return { current: 0, average: 0, min: 0, max: 0 };\n    }\n\n    const current = this.getCurrentFPS();\n    const average = this.getAverageFPS();\n    const min = Math.min(...this.frames);\n    const max = Math.max(...this.frames);\n\n    return { current, average, min, max };\n  }\n}\n\n// Global FPS monitor instance\nexport const fpsMonitor = new FPSMonitor();\n"],"names":["InputSanitizer","sanitizeInput","input","sanitized","wasModified","warnings","pattern","this","DANGEROUS_PATTERNS","test","replace","push","originalLength","length","encodeHTMLEntities","trimmed","trim","sanitizePrompt","prompt","result","substring","specialCharCount","match","totalLength","sanitizeNumber","value","min","max","defaultValue","numValue","parseFloat","isNaN","isFinite","rounded","Math","round","sanitizeColor","color","toLowerCase","inputResult","startsWith","includes","str","HTML_ENTITIES","containsOnlySafeCharacters","isSuspiciousInput","some","debounce","func","wait","immediate","timeout","args","callNow","clearTimeout","setTimeout","__publicField","performanceMonitor","constructor","Map","start","name","metadata","startTime","performance","now","activeTimers","set","metrics","end","endTime","get","duration","delete","metric","find","m","time","fn","error","timeSync","getReport","completedMetrics","filter","summary","totalOperations","averageDuration","slowestOperation","fastestOperation","durations","map","reduce","sum","d","slowest","current","fastest","clear","getMetricsFor","logReport","report"],"mappings":"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"}