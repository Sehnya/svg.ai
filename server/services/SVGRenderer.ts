/**
 * SVGRenderer - Renders final SVG markup with component expansion
 */
import type { AISVGDocument, SVGComponent } from "../types/pipeline.js";
import { ViewportDebugger } from "../utils/viewportDebugger.js";

export interface RenderOptions {
  includeMetadata?: boolean;
  optimizeOutput?: boolean;
  indentSize?: number;
  precision?: number;
}

export class SVGRenderer {
  private readonly DEFAULT_OPTIONS: RenderOptions = {
    includeMetadata: false,
    optimizeOutput: true,
    indentSize: 2,
    precision: 2,
  };

  async render(
    document: AISVGDocument,
    options?: RenderOptions
  ): Promise<string> {
    const opts = { ...this.DEFAULT_OPTIONS, ...options };

    // Start SVG element
    let svg = this.createSVGElement(document, opts);

    // Add metadata if requested
    if (opts.includeMetadata) {
      svg += this.renderMetadata(document, opts);
    }

    // Add background if specified
    if (document.metadata.palette.length > 3) {
      svg += this.renderBackground(document, opts);
    }

    // Render components in z-index order
    const sortedComponents = this.sortComponentsByZIndex(document.components);
    for (const component of sortedComponents) {
      svg += this.renderComponent(component, opts, 1);
    }

    // Close SVG element
    svg += "</svg>";

    // Optimize output if requested
    if (opts.optimizeOutput) {
      svg = this.optimizeSVG(svg, opts);
    }

    return svg;
  }

  private createSVGElement(
    document: AISVGDocument,
    options: RenderOptions
  ): string {
    const { width, height } = document.bounds;

    // Extract path commands from components to analyze viewport
    const pathCommands = this.extractPathCommands(document.components);

    // Use viewport debugger to calculate optimal viewBox
    let viewBox = `0 0 ${width} ${height}`;
    if (pathCommands.length > 0) {
      const viewportFix = ViewportDebugger.fixViewportIssues(
        pathCommands,
        width,
        height,
        0.1 // 10% padding
      );
      viewBox = viewportFix.newViewBox;
    }

    let attributes = [
      'xmlns="http://www.w3.org/2000/svg"',
      `viewBox="${viewBox}"`,
      `width="${width}"`,
      `height="${height}"`,
    ];

    // Add version info as comment if metadata is included
    let svg = "<svg " + attributes.join(" ") + ">";

    if (options.includeMetadata) {
      svg += "\n  <!-- Generated by SVG AI Code Generator -->";
      svg += `\n  <!-- Model: ${document.metadata.model} -->`;
      svg += `\n  <!-- Generated: ${document.metadata.generatedAt.toISOString()} -->`;
      svg += `\n  <!-- ViewBox: ${viewBox} -->`;
    }

    return svg;
  }

  private renderMetadata(
    document: AISVGDocument,
    options: RenderOptions
  ): string {
    const indent = " ".repeat(options.indentSize || 2);
    let metadata = "\n" + indent + "<metadata>";

    metadata +=
      "\n" +
      indent +
      '  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">';
    metadata += "\n" + indent + "    <rdf:Description>";
    metadata += `\n${indent}      <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">${this.escapeXML(document.metadata.prompt)}</dc:title>`;
    metadata += `\n${indent}      <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">${this.escapeXML(document.metadata.description)}</dc:description>`;
    metadata += `\n${indent}      <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">${document.metadata.model}</dc:creator>`;
    metadata += `\n${indent}      <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">${document.metadata.generatedAt.toISOString()}</dc:date>`;
    metadata += "\n" + indent + "    </rdf:Description>";
    metadata += "\n" + indent + "  </rdf:RDF>";
    metadata += "\n" + indent + "</metadata>";

    return metadata;
  }

  private renderBackground(
    document: AISVGDocument,
    options: RenderOptions
  ): string {
    const bgColor = document.metadata.palette[3]; // Fourth color as background
    const indent = " ".repeat(options.indentSize || 2);

    return `\n${indent}<rect width="100%" height="100%" fill="${bgColor}"/>`;
  }

  private sortComponentsByZIndex(components: SVGComponent[]): SVGComponent[] {
    // For now, render in order. In a full implementation, we'd use actual z-index values
    return [...components];
  }

  private renderComponent(
    component: SVGComponent,
    options: RenderOptions,
    depth: number
  ): string {
    const indent = " ".repeat((options.indentSize || 2) * depth);
    const precision = options.precision || 2;

    // Start element
    let element = `\n${indent}<${component.element}`;

    // Add attributes
    for (const [key, value] of Object.entries(component.attributes)) {
      const formattedValue = this.formatAttributeValue(value, precision);
      element += ` ${key}="${formattedValue}"`;
    }

    // Handle self-closing vs container elements
    if (this.isSelfClosingElement(component.element)) {
      element += "/>";
    } else {
      element += ">";

      // Render children if present
      if (component.children && component.children.length > 0) {
        for (const child of component.children) {
          element += this.renderComponent(child, options, depth + 1);
        }
        element += `\n${indent}`;
      }

      element += `</${component.element}>`;
    }

    return element;
  }

  private formatAttributeValue(
    value: string | number,
    precision: number
  ): string {
    if (typeof value === "number") {
      // Round to specified precision
      if (Number.isInteger(value)) {
        return value.toString();
      } else {
        return value.toFixed(precision).replace(/\.?0+$/, "");
      }
    }

    return this.escapeXML(value.toString());
  }

  private isSelfClosingElement(elementType: string): boolean {
    const selfClosingElements = [
      "circle",
      "ellipse",
      "line",
      "rect",
      "polygon",
      "polyline",
      "path",
    ];
    return selfClosingElements.includes(elementType);
  }

  private escapeXML(text: string): string {
    return text
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#39;");
  }

  private optimizeSVG(svg: string, options: RenderOptions): string {
    let optimized = svg;

    // Remove unnecessary whitespace between elements
    optimized = optimized.replace(/>\s+</g, "><");

    // Remove trailing zeros from decimal numbers
    optimized = optimized.replace(/(\d+)\.0+(?=["'\s>])/g, "$1");

    // Simplify consecutive identical attributes (basic optimization)
    // This is a simplified version - a full optimizer would be more sophisticated

    // Remove empty groups
    optimized = optimized.replace(/<g[^>]*>\s*<\/g>/g, "");

    // Combine consecutive transforms (basic case)
    optimized = optimized.replace(
      /transform="([^"]*)" transform="([^"]*)"/g,
      'transform="$1 $2"'
    );

    return optimized;
  }

  // Utility method for rendering individual components (useful for testing)
  renderComponentOnly(
    component: SVGComponent,
    options?: RenderOptions
  ): string {
    const opts = { ...this.DEFAULT_OPTIONS, ...options };
    return this.renderComponent(component, opts, 0).trim();
  }

  // Method to render just the SVG content without wrapper
  renderContent(document: AISVGDocument, options?: RenderOptions): string {
    const opts = { ...this.DEFAULT_OPTIONS, ...options };
    let content = "";

    // Add background if specified
    if (document.metadata.palette.length > 3) {
      content += this.renderBackground(document, opts);
    }

    // Render components
    const sortedComponents = this.sortComponentsByZIndex(document.components);
    for (const component of sortedComponents) {
      content += this.renderComponent(component, opts, 1);
    }

    return content;
  }

  // Extract path commands from SVG components for viewport analysis
  private extractPathCommands(components: SVGComponent[]): any[] {
    const commands: any[] = [];

    for (const component of components) {
      // Convert component attributes to path commands for analysis
      switch (component.element) {
        case "circle":
          const cx = Number(component.attributes.cx) || 0;
          const cy = Number(component.attributes.cy) || 0;
          const r = Number(component.attributes.r) || 0;
          // Approximate circle as path commands for bounds calculation
          commands.push(
            { cmd: "M", coords: [cx - r, cy] },
            { cmd: "A", coords: [r, r, 0, 0, 1, cx + r, cy] },
            { cmd: "A", coords: [r, r, 0, 0, 1, cx - r, cy] },
            { cmd: "Z", coords: [] }
          );
          break;

        case "rect":
          const x = Number(component.attributes.x) || 0;
          const y = Number(component.attributes.y) || 0;
          const w = Number(component.attributes.width) || 0;
          const h = Number(component.attributes.height) || 0;
          commands.push(
            { cmd: "M", coords: [x, y] },
            { cmd: "L", coords: [x + w, y] },
            { cmd: "L", coords: [x + w, y + h] },
            { cmd: "L", coords: [x, y + h] },
            { cmd: "Z", coords: [] }
          );
          break;

        case "polygon":
        case "polyline":
          const points = String(component.attributes.points || "").trim();
          if (points) {
            const coords = points
              .split(/[\s,]+/)
              .map(Number)
              .filter((n) => !isNaN(n));
            if (coords.length >= 2) {
              commands.push({ cmd: "M", coords: [coords[0], coords[1]] });
              for (let i = 2; i < coords.length; i += 2) {
                if (i + 1 < coords.length) {
                  commands.push({
                    cmd: "L",
                    coords: [coords[i], coords[i + 1]],
                  });
                }
              }
              if (component.element === "polygon") {
                commands.push({ cmd: "Z", coords: [] });
              }
            }
          }
          break;

        case "path":
          // Parse path data (simplified - would need full path parser for complex paths)
          const d = String(component.attributes.d || "");
          const pathCommands = this.parseSimplePath(d);
          commands.push(...pathCommands);
          break;
      }
    }

    return commands;
  }

  // Simple path parser for basic path commands
  private parseSimplePath(pathData: string): any[] {
    const commands: any[] = [];
    const tokens =
      pathData.match(/[MmLlHhVvCcSsQqTtAaZz][^MmLlHhVvCcSsQqTtAaZz]*/g) || [];

    for (const token of tokens) {
      const cmd = token[0];
      const coords = token
        .slice(1)
        .trim()
        .split(/[\s,]+/)
        .map(Number)
        .filter((n) => !isNaN(n));

      switch (cmd.toUpperCase()) {
        case "M":
        case "L":
          if (coords.length >= 2) {
            commands.push({
              cmd: cmd.toUpperCase(),
              coords: [coords[0], coords[1]],
            });
          }
          break;
        case "C":
          if (coords.length >= 6) {
            commands.push({ cmd: "C", coords: coords.slice(0, 6) });
          }
          break;
        case "Q":
          if (coords.length >= 4) {
            commands.push({ cmd: "Q", coords: coords.slice(0, 4) });
          }
          break;
        case "Z":
          commands.push({ cmd: "Z", coords: [] });
          break;
      }
    }

    return commands;
  }

  // Method to validate rendered SVG
  validateRenderedSVG(svg: string): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];

    // Basic structural validation
    if (!svg.startsWith("<svg")) {
      errors.push("SVG does not start with <svg element");
    }

    if (!svg.endsWith("</svg>")) {
      errors.push("SVG does not end with </svg>");
    }

    if (!svg.includes('xmlns="http://www.w3.org/2000/svg"')) {
      errors.push("SVG missing required xmlns attribute");
    }

    if (!svg.includes("viewBox=")) {
      errors.push("SVG missing viewBox attribute");
    }

    // Check for unclosed tags (basic check)
    const openTags = (svg.match(/<[^/][^>]*[^/]>/g) || []).length;
    const closeTags = (svg.match(/<\/[^>]+>/g) || []).length;
    const selfClosingTags = (svg.match(/<[^>]*\/>/g) || []).length;

    if (openTags !== closeTags + selfClosingTags) {
      errors.push("Mismatched opening and closing tags");
    }

    return {
      isValid: errors.length === 0,
      errors,
    };
  }
}
