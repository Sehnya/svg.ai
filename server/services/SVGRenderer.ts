/**
 * SVGRenderer - Renders final SVG markup with component expansion
 */
import type { AISVGDocument, SVGComponent } from "../types/pipeline.js";

export interface RenderOptions {
  includeMetadata?: boolean;
  optimizeOutput?: boolean;
  indentSize?: number;
  precision?: number;
}

export class SVGRenderer {
  private readonly DEFAULT_OPTIONS: RenderOptions = {
    includeMetadata: false,
    optimizeOutput: true,
    indentSize: 2,
    precision: 2,
  };

  async render(
    document: AISVGDocument,
    options?: RenderOptions
  ): Promise<string> {
    const opts = { ...this.DEFAULT_OPTIONS, ...options };

    // Start SVG element
    let svg = this.createSVGElement(document, opts);

    // Add metadata if requested
    if (opts.includeMetadata) {
      svg += this.renderMetadata(document, opts);
    }

    // Add background if specified
    if (document.metadata.palette.length > 3) {
      svg += this.renderBackground(document, opts);
    }

    // Render components in z-index order
    const sortedComponents = this.sortComponentsByZIndex(document.components);
    for (const component of sortedComponents) {
      svg += this.renderComponent(component, opts, 1);
    }

    // Close SVG element
    svg += "</svg>";

    // Optimize output if requested
    if (opts.optimizeOutput) {
      svg = this.optimizeSVG(svg, opts);
    }

    return svg;
  }

  private createSVGElement(
    document: AISVGDocument,
    options: RenderOptions
  ): string {
    const { width, height } = document.bounds;
    const viewBox = `0 0 ${width} ${height}`;

    let attributes = [
      'xmlns="http://www.w3.org/2000/svg"',
      `viewBox="${viewBox}"`,
      `width="${width}"`,
      `height="${height}"`,
    ];

    // Add version info as comment if metadata is included
    let svg = "<svg " + attributes.join(" ") + ">";

    if (options.includeMetadata) {
      svg += "\n  <!-- Generated by SVG AI Code Generator -->";
      svg += `\n  <!-- Model: ${document.metadata.model} -->`;
      svg += `\n  <!-- Generated: ${document.metadata.generatedAt.toISOString()} -->`;
    }

    return svg;
  }

  private renderMetadata(
    document: AISVGDocument,
    options: RenderOptions
  ): string {
    const indent = " ".repeat(options.indentSize || 2);
    let metadata = "\n" + indent + "<metadata>";

    metadata +=
      "\n" +
      indent +
      '  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">';
    metadata += "\n" + indent + "    <rdf:Description>";
    metadata += `\n${indent}      <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">${this.escapeXML(document.metadata.prompt)}</dc:title>`;
    metadata += `\n${indent}      <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">${this.escapeXML(document.metadata.description)}</dc:description>`;
    metadata += `\n${indent}      <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">${document.metadata.model}</dc:creator>`;
    metadata += `\n${indent}      <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">${document.metadata.generatedAt.toISOString()}</dc:date>`;
    metadata += "\n" + indent + "    </rdf:Description>";
    metadata += "\n" + indent + "  </rdf:RDF>";
    metadata += "\n" + indent + "</metadata>";

    return metadata;
  }

  private renderBackground(
    document: AISVGDocument,
    options: RenderOptions
  ): string {
    const bgColor = document.metadata.palette[3]; // Fourth color as background
    const indent = " ".repeat(options.indentSize || 2);

    return `\n${indent}<rect width="100%" height="100%" fill="${bgColor}"/>`;
  }

  private sortComponentsByZIndex(components: SVGComponent[]): SVGComponent[] {
    // For now, render in order. In a full implementation, we'd use actual z-index values
    return [...components];
  }

  private renderComponent(
    component: SVGComponent,
    options: RenderOptions,
    depth: number
  ): string {
    const indent = " ".repeat((options.indentSize || 2) * depth);
    const precision = options.precision || 2;

    // Start element
    let element = `\n${indent}<${component.element}`;

    // Add attributes
    for (const [key, value] of Object.entries(component.attributes)) {
      const formattedValue = this.formatAttributeValue(value, precision);
      element += ` ${key}="${formattedValue}"`;
    }

    // Handle self-closing vs container elements
    if (this.isSelfClosingElement(component.element)) {
      element += "/>";
    } else {
      element += ">";

      // Render children if present
      if (component.children && component.children.length > 0) {
        for (const child of component.children) {
          element += this.renderComponent(child, options, depth + 1);
        }
        element += `\n${indent}`;
      }

      element += `</${component.element}>`;
    }

    return element;
  }

  private formatAttributeValue(
    value: string | number,
    precision: number
  ): string {
    if (typeof value === "number") {
      // Round to specified precision
      if (Number.isInteger(value)) {
        return value.toString();
      } else {
        return value.toFixed(precision).replace(/\.?0+$/, "");
      }
    }

    return this.escapeXML(value.toString());
  }

  private isSelfClosingElement(elementType: string): boolean {
    const selfClosingElements = [
      "circle",
      "ellipse",
      "line",
      "rect",
      "polygon",
      "polyline",
      "path",
    ];
    return selfClosingElements.includes(elementType);
  }

  private escapeXML(text: string): string {
    return text
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#39;");
  }

  private optimizeSVG(svg: string, options: RenderOptions): string {
    let optimized = svg;

    // Remove unnecessary whitespace between elements
    optimized = optimized.replace(/>\s+</g, "><");

    // Remove trailing zeros from decimal numbers
    optimized = optimized.replace(/(\d+)\.0+(?=["'\s>])/g, "$1");

    // Simplify consecutive identical attributes (basic optimization)
    // This is a simplified version - a full optimizer would be more sophisticated

    // Remove empty groups
    optimized = optimized.replace(/<g[^>]*>\s*<\/g>/g, "");

    // Combine consecutive transforms (basic case)
    optimized = optimized.replace(
      /transform="([^"]*)" transform="([^"]*)"/g,
      'transform="$1 $2"'
    );

    return optimized;
  }

  // Utility method for rendering individual components (useful for testing)
  renderComponentOnly(
    component: SVGComponent,
    options?: RenderOptions
  ): string {
    const opts = { ...this.DEFAULT_OPTIONS, ...options };
    return this.renderComponent(component, opts, 0).trim();
  }

  // Method to render just the SVG content without wrapper
  renderContent(document: AISVGDocument, options?: RenderOptions): string {
    const opts = { ...this.DEFAULT_OPTIONS, ...options };
    let content = "";

    // Add background if specified
    if (document.metadata.palette.length > 3) {
      content += this.renderBackground(document, opts);
    }

    // Render components
    const sortedComponents = this.sortComponentsByZIndex(document.components);
    for (const component of sortedComponents) {
      content += this.renderComponent(component, opts, 1);
    }

    return content;
  }

  // Method to validate rendered SVG
  validateRenderedSVG(svg: string): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];

    // Basic structural validation
    if (!svg.startsWith("<svg")) {
      errors.push("SVG does not start with <svg element");
    }

    if (!svg.endsWith("</svg>")) {
      errors.push("SVG does not end with </svg>");
    }

    if (!svg.includes('xmlns="http://www.w3.org/2000/svg"')) {
      errors.push("SVG missing required xmlns attribute");
    }

    if (!svg.includes("viewBox=")) {
      errors.push("SVG missing viewBox attribute");
    }

    // Check for unclosed tags (basic check)
    const openTags = (svg.match(/<[^/][^>]*[^/]>/g) || []).length;
    const closeTags = (svg.match(/<\/[^>]+>/g) || []).length;
    const selfClosingTags = (svg.match(/<[^>]*\/>/g) || []).length;

    if (openTags !== closeTags + selfClosingTags) {
      errors.push("Mismatched opening and closing tags");
    }

    return {
      isValid: errors.length === 0,
      errors,
    };
  }
}
